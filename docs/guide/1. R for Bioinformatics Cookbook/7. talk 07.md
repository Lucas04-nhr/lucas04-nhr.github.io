---
title: Strings and regular expression
createTime: 2025/12/07 21:59:34
permalink: /docs/r-course/talk07/
---

# Talk 07 {#talk07}

::: note
Reference: [R for Data Science](https://r4ds.had.co.nz)

The book updated to 2^nd^ ed. on July,2023, here’ s a [link](https://r4ds.hadley.nz) to the official website.

  ::: flex around center
  <LinkCard 
    icon="ic:outline-description"
    title="View the original slide"
    href="https://github.com/Lucas04-nhr/R-for-Data-Science/blob/main/talk07.pdf" > 
  </LinkCard>

  <LinkCard 
    icon="ic:round-document-scanner"
    title="View the original Rmd file"
    href="https://github.com/Lucas04-nhr/R-for-Data-Science/blob/main/talk07.Rmd" > 
  </LinkCard>
  :::
  
:::

## Prerequisites {#prerequisites}

Before you start…

```R
library(stringr)
```

## `stringi` {#stringi}

 `stringi`(Following are based on the official R Documentation)

### Description {#stringi-description}

​	`stringi` is an R package for fast, correct, consistent, and convenient string/text manipulation. It gives predictable results on every platform, in each locale, and under any native character encoding.

### Facilities available {#stringi-facilities}

**String searching facilities** including pattern searching, matching, string splitting, and so on. The following independent search engines are provided:
  - Regular expressions with ICU (Java-like) syntax
  - Fast, locale-independent, byte-wise pattern matching
  - Locale-aware pattern matching for natural language processing tasks
  - Seeking elements of particular character classes, like "all white-spaces" or "all digits"
  - Text boundary analysis

Here are some commonly used functions in the `stringi` package:

- `stri_datetime_format` for date/time formatting and parsing. Also refer to the documentation for other date/time/time zone-related operations.
- `stri_stats_general` and `stri_stats_latex` for gathering some fancy statistics on a character vector's contents.
- `stri_join`, `stri_dup`, `%s+%`, and `stri_flatten` for concatenation-based operations.
- `stri_sub` for extracting and replacing substrings, and `stri_reverse` for reversing all code points in a string.
- `stri_length` (among others) for determining the number of code points in a string. See also `stri_count_boundaries` for counting the number of Unicode characters and `stri_width` for approximating the width of a string.
- `stri_trim` (among others) for trimming characters from the beginning or/and end of a string, and `stri_pad` for padding strings so that they are of the same width. Additionally, `stri_wrap` wraps text into lines.
- `stri_trans_tolower` (among others) for case mapping, i.e., conversion to lower, UPPER, or Title Case, `stri_trans_nfc` (among others) for Unicode normalization, `stri_trans_char` for translating individual code points, and `stri_trans_general` for other universal text transforms, including transliteration.
- `stri_cmp`, `%s<%`, `stri_order`, `stri_sort`, `stri_rank`, `stri_unique`, and `stri_duplicated` for collation-based, locale-aware operations.
- `stri_split_lines` (among others) to split a string into text lines.
- `stri_escape_unicode` (among others) for escaping some code points.
- `stri_rand_strings`, `stri_rand_shuffle`, and `stri_rand_lipsum` for generating (pseudo)random strings.
- `stri_read_raw`, `stri_read_lines`, and `stri_write_lines` for reading and writing text files.

## `writeLines` function in R {#stringi-writelines}

Write text lines to a connection.

### Usage {#writelines-usage}

```
writeLines(text, con = stdout(), sep = "\n", useBytes = FALSE)
```

### Arguments {#writelines-arguments}

:::table title="Arguments of the function" align="center" fullWidth copy="all"
| Argument | Description |
| :-: | :- |
| `text` | A character vector |
| `con` | A connection object or a character string. |
| `sep` | character string. A string to be written to the connection after each line of text. |
| `useBytes` | logical. See ‘Details’. |
:::

### Details {#writelines-details}

If the `con` is a character string, the function calls `file` to obtain a file connection which is opened for the duration of the function call. (tilde expansion of the file path is done by `file`.)

If the connection is open it is written from its current position. If it is not open, it is opened for the duration of the call in `"wt"` mode and then closed again.

Normally `writeLines` is used with a text-mode connection, and the default separator is converted to the normal separator for that platform (LF on Unix/Linux, CRLF on Windows). For more control, open a binary connection and specify the precise value you want written to the file in `sep`. For even more control, use `writeChar` on a binary connection.

`useBytes` is for expert use. Normally (when false) character strings with marked encodings are converted to the current encoding before being passed to the connection (which might do further re-encoding). `useBytes = TRUE` suppresses the re-encoding of marked strings so they are passed byte-by-byte to the connection: this can be useful when strings have already been re-encoded by e.g. `iconv`. (It is invoked automatically for strings with marked encoding `"bytes"`.)

## Difference between double quote(`“”`) and single quote(`‘’`) {#stringi-quotes}

In R and its string manipulation package `stringr`, there is no difference between strings defined with double quotes (`"`) and single quotes (`'`). Both are used to define strings and you can use either depending on your preference or the situation.

For instance, if your string contains a single quote, you might find it easier to enclose the string in double quotes, and vice versa. Here's an example:

```R
# Using double quotes when the string contains a single quote
string1 = "It's a beautiful day"

# Using single quotes when the string contains a double quote
string2 = 'He said, "Hello, world!"'
```

In both cases, R will interpret the contents between the quotes as a string. 

### Comparison between `stringr` functions and base R functions {#stringr-comparison}

::: note
Some of the functions in the `stringr` package are similar in function to those that come with the system.
:::

Here are examples comparing some functions from the `stringr` package with their counterparts from base R:

1. `str_length()` vs. `nchar()`:

    ```R
    library(stringr)

    # Using str_length from stringr
    string = c("apple", NA, "banana", "")
    str_length(string)
    # Output: 5   NA   6   0

    # Using nchar from base R
    nchar(string)
    # Output: 5  NA   6   0
    ```

    Both `str_length()` and `nchar()` count the number of characters in each string element. However, `str_length()` handles missing values (`NA`) more consistently by returning `NA`, whereas `nchar()` might treat `NA` differently in certain cases.

2. `str_sub()` vs. `substr()`:

    ```R
    # Using str_sub from stringr
    string = c("hello", "world", "example")
    str_sub(string, start = 2, end = 4)
    # Output: "ell" "orl" "xam"

    # Using substr from base R
    substr(string, start = 2, stop = 4)
    # Output: "ell" "orl" "xam"
    ```

    Both `str_sub()` and `substr()` extract substrings based on specified start and end positions. However, `str_sub()` allows negative indices to count from the end of the string, and it handles missing values more consistently.

3. `str_replace()` vs. `sub()` or `gsub()`:

    ```R
    # Using str_replace from stringr
    string = c("apple pie", "banana bread", "cherry cake")
    str_replace(string, pattern = "a", replacement = "X")
    # Output: "Xpple pie" "bXnXnX breXd" "chXrry cXke"

    # Using sub from base R
    sub(pattern = "a", replacement = "X", x = string)
    # Output: "Xpple pie" "bXnana bread" "cherry cake"
    ```

    Both `str_replace()` and `sub()` are used for replacing parts of a string. However, `str_replace()` has a more intuitive interface and handles missing values more gracefully compared to `sub()`.

::: info
These examples demonstrate how `stringr` functions can be more consistent and user-friendly in handling various string operations compared to their base R counterparts.
:::

### Comparison between `stringi` functions and base R functions {#stringi-comparison}

::: note
Some of the functions in the `stringi` package are similar in function to those that come with the system.
:::

Here are some functions in the `stringi` package that share similar functionalities with base R's string functions, along with examples showcasing their differences:

1. `stri_length()` vs. `nchar()`:

    - `stri_length()` in `stringi` calculates the number of code points in a string, accounting for Unicode characters.
    - `nchar()` in base R counts the number of characters in a string, but it might not handle Unicode characters as accurately as `stri_length()`.

    ```R
    library(stringi)
    
    # Using stri_length from stringi
    string = "café"
    stri_length(string)
    # Output: 4
    
    # Using nchar from base R
    nchar(string)
    # Output: 4
    ```

    In this example, both `stri_length()` and `nchar()` return the same count for ASCII characters. However, when dealing with Unicode characters, `stri_length()` can accurately count them as individual code points, whereas `nchar()` might not handle them correctly.

2. `stri_split_*()` vs. `strsplit()`:
    - `stri_split_*()` functions in `stringi` split a string based on various criteria like fixed patterns, regular expressions, or character classes.
    - `strsplit()` in base R performs a similar operation but might differ in handling certain edge cases and Unicode characters.

    ```R
    # Using stri_split_* from stringi
    string = "apple, orange, café"
    stri_split_fixed(string, pattern = ", ")
    # Output: list("apple", "orange", "café")
    
    # Using strsplit from base R
    strsplit(string, split = ", ")
    # Output: list("apple", "orange", "caf", "é")
    ```

    Here, `stri_split_fixed()` correctly splits the string, including the accented character "é," while `strsplit()` treats the accented "é" as two separate characters due to how it handles Unicode.

3. `stri_detect()` vs. `grepl()`:
    - `stri_detect()` in `stringi` checks if a pattern exists in a string and returns a logical value.
    - `grepl()` in base R performs a similar task but might differ in its handling of Unicode characters and certain pattern matching options.

    ```R
    # Using stri_detect from stringi
    string = "This is a café"
    stri_detect(string, regex = "café")
    # Output: TRUE
    
    # Using grepl from base R
    grepl("café", string)
    # Output: FALSE
    ```

    In this example, `stri_detect()` correctly detects the presence of the word "café," while `grepl()` returns a different result due to potential differences in Unicode handling or pattern matching options.

::: info
The examples highlight how `stringi` functions like `stri_length()`, `stri_split_*()`, and `stri_detect()` differ from their base R counterparts (`nchar()`, `strsplit()`, and `grepl()`) by providing more accurate handling of Unicode characters and often more versatile string manipulation options.
:::

###  Difference between `toupper()`, `tolower()` and `stri_reverse()` {#stringi-case-reverse}

The functions `toupper()` and `tolower()` in base R and `stri_reverse()` in the `stringi` package perform similar tasks, but there are some differences in their functionality and usage:

1. `toupper()` and `tolower()` in Base R:
    - `toupper()` converts characters in a string to uppercase.
    - `tolower()` converts characters in a string to lowercase.

    ```R
    # Using toupper and tolower from base R
    string = "Hello World!"
    
    toupper(string)
    # Output: "HELLO WORLD!"
    
    tolower(string)
    # Output: "hello world!"
    ```

    These functions are straightforward and work well for ASCII characters, converting them to uppercase or lowercase, respectively. However, they might not handle Unicode characters or locale-specific transformations.

2. `stri_reverse()` in `stringi`:
    - `stri_reverse()` reverses the order of characters in a string, including handling multibyte characters and Unicode sequences.

    ```R
    library(stringi)
    
    # Using stri_reverse from stringi
    string = "café"
    
    stri_reverse(string)
    # Output: "éfac"
    ```

    `stri_reverse()` reverses the characters in the string accurately, even when dealing with Unicode characters or multibyte sequences. It ensures correct reversal of characters irrespective of their encoding.

::: info
The key distinction lies in the handling of character cases and character sequence reversal. While `toupper()` and `tolower()` focus on case transformations for ASCII characters, `stri_reverse()` in `stringi` concentrates on accurately reversing character sequences, making it more suitable for handling multibyte characters and Unicode strings.
:::

### Tricks for remembering `stringr` and `stringi` functions {#stringi-tricks}

* ``` stringi ``` The functions in the package all start with ``` stri_ ```.
* ``` strinr ``` starts with ``` str_ ```.

## Regex - Regular Expression

1. Character classes:What characters are (not) matched?

```R
# Example 01
"abc_123_??$$^" %>% str_extract("\\s+") # Does this string include spaces? 
"abc_123_??$$^" %>% str_extract("\\d+") # Numbers? 
"abc_123_??$$^" %>% str_extract("\\w+") # [A-z0-9_]
```

```str_extract``` : Take out the first match.

2. Matching position

```R
# Example 02
# STRING ending in 'wei'
c("chen wei hua", "chen wei", "chen") %>% str_subset("wei$")

# CHARACTER ending in 'wei' 
c("chen wei hua", "chen wei", "chen") %>% str_subset("wei\\b")
```

3. Number of matches

```R
# Example 03
"1234abc" %>% str_extract("\\d+")
"1234abc" %>% str_extract("\\d{3}")
"1234abc" %>% str_extract("\\d{5,6}")
"1234abc" %>% str_extract("\\d{2,6}")
```

4. Classes and groups

  ![Regular Expressions - Classes and Groups](https://cdn.jsdelivr.net/gh/Lucas04-nhr/Pictures@main/uPic/regexprs_classes_groups.png)

5. Special characters

  ![Regular Expressions - Special Characters](https://cdn.jsdelivr.net/gh/Lucas04-nhr/Pictures@main/uPic/regexprs_special_characters.png)
