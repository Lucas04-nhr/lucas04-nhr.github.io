---
title: Data iteration & parallel computing
createTime: 2025/12/07 21:59:34
permalink: /docs/r-course/talk08/
---

# Talk 08 {#talk08}

::: note
Reference: [R for Data Science](https://r4ds.had.co.nz)

The book updated to 2^nd^ ed. on July, 2023, here’s a [link](https://r4ds.hadley.nz) to the official website.

::: flex around center
<LinkCard 
    icon="ic:outline-description"
    title="View the original slide"
    href="https://github.com/Lucas04-nhr/R-for-Data-Science/blob/main/talk08.pdf" >
</LinkCard>

<LinkCard 
    icon="ic:round-document-scanner"
    title="View the original Rmd file"
    href="https://github.com/Lucas04-nhr/R-for-Data-Science/blob/main/talk08.Rmd" >
</LinkCard>
:::

:::

## Iteration Basics {#iteration}

### `for loop` , getting data ready {#for-loop}

Lookat this example:

```R :::collapsed-lines=7
df =
  tibble(
    a = rnorm(100),
    b = rnorm(100),
    c = rnorm(100),
    d = rnorm(100)
  )

# Calculate row means
res1 =
  vector("double", nrow(df))
for(row_idx in 1:nrow(df)){
  res1[row_idx] =
    mean( as.numeric(df[row_idx, ]))
}

res2 = c()
for(row_idx in 1:nrow(df)){
  res2[length(res2) + 1] =
    mean(as.numeric(df[row_idx, ]))
}

# Similar to Python

# Calculate column means
res2 =
  vector("double", ncol(df))
for(col_idx in 1:ncol(df)){
  res2[col_idx] =
    mean(df[[col_idx]])
}
```

You can replace it with `for loop`:

```R
rowMeans(df)
colMeans(df)
```

Here are some other functions:

```R
rowSums(df)
colSums(df)
```

### `apply` functions {#apply-functions}

You can use `apply` with customizable function.

```R
df %>% apply(
  .,
  2,
  function(x) {
    return(
      c(
        n = length(x),
        mean = mean(x),
        median = median(x)
      )
    )
  }
)
```

### Something about `tapply()` {#tapply}

The `tapply()` function in R is used to apply a function over subsets of a vector, splitting it by a factor or list of factors. It stands for "table apply" and is particularly useful for summarizing data by groups or categories.

Here's a breakdown of its usage:

```R
tapply(X, INDEX, FUN)
```

- `X`: The vector (or array) on which you want to apply the function.
- `INDEX`: A factor or list of factors that define the groups. These factors determine how the vector `X` is split.
- `FUN`: The function to be applied to each subset of `X`.

==**Example**=={.note}

```R
# Creating a sample vector and a corresponding factor
values = c(10, 20, 30, 40, 50)
categories = factor(c("A", "B", "A", "B", "A"))

# Applying the mean function over subsets defined by the categories
tapply(values, categories, mean)
```

In this example, `tapply()` calculates the mean of the `values` vector for each category defined by the `categories` factor. It splits the `values` vector into subsets based on the categories and applies the `mean()` function to each subset, returning the mean values for categories "A" and "B".

The result would be something like:

```
A    B
30   30
```

This indicates that the mean value for category "A" is 30, and the mean value for category "B" is also 30 in this case.

::: note
`lapply()`, `sapply()`, and similar functions work on elements of lists or vectors. In contrast, `tapply()` focuses on splitting a vector by factors and applying a function to these subsets, providing aggregated results for each subset determined by the factors.
:::

### Diffrences between `apply` in base R and the package `dplyr` {#differences-apply-dplyr}

1. `apply` functions in base R:

   - The `apply` family of functions (`apply()`, `lapply()`, `sapply()`, `vapply()`, etc.) in base R are used for applying a function over margins of arrays or data structures like matrices, arrays, and lists.
   - `apply()` is used primarily for applying functions to the rows or columns of matrices or arrays, while `lapply()` and `sapply()` are more focused on lists.
   - These functions are useful for repetitive operations across rows or columns without explicitly using loops.

   ```R
   # Creating a matrix
   mat = matrix(1:12, nrow = 3, ncol = 4)

   # Applying sum function to rows (1) or columns (2) of the matrix
   apply(mat, 1, sum)  # Sums of each row
   apply(mat, 2, sum)  # Sums of each column
   ```

2. `dplyr` package:

   - `dplyr` is a powerful package in R for data manipulation and transformation. It provides a set of functions (`filter()`, `mutate()`, `select()`, `group_by()`, `summarize()`, etc.) that enable easy and intuitive data manipulation.
   - It's designed to work well with data frames and offers a more streamlined and readable syntax for performing common data manipulation tasks.

   ```R :::collapsed-lines=7
   library(dplyr)

   # Creating a sample data frame
   df = data.frame(
     Name = c("Alice", "Bob", "Charlie"),
     Age = c(25, 30, 28),
     Salary = c(40000, 50000, 45000)
   )

   # Filtering and selecting specific rows and columns
   filtered_df = df %>%
     filter(Age > 25) %>%
     select(Name, Salary)

   filtered_df
   ```

   This `dplyr` example filters rows where `Age` is greater than 25 and selects only the `Name` and `Salary` columns. The `%>%` operator (pipe) chains together multiple operations, making the code more readable and concise.

::: note
The `apply` family in base R is ideal for applying functions to matrices, arrays, or lists across rows or columns, while `dplyr` focuses on intuitive data manipulation operations for data frames, providing a cleaner syntax and ease of use for common data transformation tasks.
:::

## More on iteration: `purrr` package {#purrr}

### About `purrr` {#about-purrr}

::: note
You can find more about this package [here](https://purrr.tidyverse.org/)
:::

`purrr` enhances R’s functional programming (FP) toolkit by providing a complete and consistent set of tools for working with functions and vectors. If you’ve never heard of FP before, the best place to start is the family of `map()`functions which allow you to replace many for loops with code that is both more succinct and easier to read. The best place to learn about the `map()` functions is the [iteration chapter](https://r4ds.had.co.nz/iteration.html) in R for data science.

### Simple Usage {#simple-usage}

The following example uses `purrr `to solve a fairly realistic problem: split a data frame into pieces, fit a model to each piece, compute the summary, then extract the R^2^.

```R
library(purrr)

mtcars |>
  split(mtcars$cyl) |>  # from base R
  map(\(df) lm(mpg ~ wt, data = df)) |>
  map(summary) %>%
  map_dbl("r.squared")

#>         4         6         8
#> 0.5086326 0.4645102 0.4229655
```

This example illustrates some of the advantages of `purrr` functions over the equivalents in base R:

- The first argument is always the data, so purrr works naturally with the pipe.
- All `purrr` functions are type-stable. They always return the advertised output type (`map()` returns lists; `map_dbl()` returns double vectors), or they throw an error.
- All `map()` functions accept functions (named, anonymous, and lambda), character vector (used to extract components by name), or numeric vectors (used to extract by position).

### Detailed Usage {#detailed-usage}

`purrr` is a powerful package in R that focuses on enhancing and simplifying the process of working with functions and vectors. Developed as part of the tidyverse ecosystem, `purrr` provides a consistent and coherent set of tools for functional programming, iteration, and working with lists and vectors.

Here are some key aspects and functionalities of `purrr`:

1. Functional Programming

   - `purrr` promotes functional programming paradigms in R, enabling users to work with functions as first-class objects.
   - It provides functions like `map()`, `map2()`, `pmap()`, `walk()`, and more, which allow applying functions over elements of lists or vectors.

2. Consistency Across Data Structures

   - `purrr` functions exhibit consistent behavior across various data structures, such as lists, vectors, and data frames.
   - These functions can work seamlessly with different data structures, making code more readable and maintainable.

3. Iteration and Mapping

   - `map()` is a key function in `purrr` that iterates over elements of a list or vector, applying a function to each element and returning the results.
   - `map2()` is similar to `map()` but allows iterating over two vectors simultaneously.
   - `pmap()` extends this functionality to iterate over multiple vectors or lists simultaneously.

4. Simplified and Cleaner Syntax

   - `purrr` functions often provide a more consistent and cleaner syntax compared to base R functions for similar operations.
   - The use of the pipe `%>%` from the tidyverse allows chaining `purrr` functions together, resulting in more readable code.

5. Working with Lists and Data Frames
   - `purrr` provides functions to efficiently manipulate and iterate over elements in lists and data frames.
   - Functions like `map()` and `map_dbl()` can be used to apply functions to each column of a data frame and collect results in an output structure.

Example of `map()` in `purrr`:

```R
library(purrr)

# Applying sqrt function to each element of a list
numbers = list(a = 1:5, b = 6:10)
result = map(numbers, sqrt)

result
# Output: List of 2
# $ a: num [1:5] 1 1.41 1.73 2 2.24
# $ b: num [1:5] 2.45 2.65 2.83 3 3.16
```

This code applies the `sqrt()` function to each element of the list `numbers`, returning a list with the square roots of each element.

`purrr` simplifies and enhances functional programming in R, offering a consistent and expressive way to work with functions, lists, vectors, and data frames, making data manipulation and iteration more straightforward and concise.

### Examples {#examples}

Here are some specific functionalities and examples of `purrr`:

1. Mapping Functions

   `map()` applies a function to each element of a list or vector, returning a list.

   ```R :::collapsed-lines=7
   library(purrr)

   # Squaring each element in a vector using map()
   numbers = 1:5
   squared = map(numbers, ~ .x^2)

   squared
   # Output: List of 5
   # $ : int 1
   # $ : int 4
   # $ : int 9
   # $ : int 16
   # $ : int 25
   ```

2. Mapping Functions over Multiple Inputs

   `map2()` allows applying a function that takes two inputs to corresponding elements of two vectors.

   ```R :::collapsed-lines=7
   library(purrr)
   # Multiplying elements of two vectors element-wise
   vector1 = 1:5
   vector2 = 6:10
   product = map2(vector1, vector2, ~ .x * .y)

   product
   # Output: List of 5
   # $ : int 6
   # $ : int 14
   # $ : int 24
   # $ : int 36
   # $ : int 50
   ```

3. Working with Data Frames

   `map_df()` and similar functions allow applying a function to each column of a data frame and combining results into a data frame.

   ```R :::collapsed-lines=7
   library(purrr)
   # Creating a data frame
   df = data.frame(A = 1:5, B = 6:10)

   # Doubling each column in the data frame
   doubled = map_df(df, ~ .x * 2)

   doubled
   # Output: A tibble: 5 × 2
   #       A     B
   #   <dbl> <dbl>
   # 1     2    12
   # 2     4    14
   # 3     6    16
   # 4     8    18
   # 5    10    20
   ```

4. Iteration and Applying Functions

   `walk()` applies a function to each element without returning a result, useful for side effects or performing operations without output.

   ```R :::collapsed-lines=4
   library(purrr)
   # Printing each element of a list using walk()
   fruits = list("apple", "banana", "orange")
   walk(fruits, print)
   # Output:
   # [1] "apple"
   # [1] "banana"
   # [1] "orange"
   ```

::: info
`purrr` simplifies functional programming by providing intuitive functions (`map()`, `map2()`, `walk()`, etc.) that allow iteration over elements, applying functions, and collecting results, making code more concise and readable in scenarios involving lists, vectors, and data frames.
:::

### Function `reduce()` and `accumulate()` {#reduce-accumulate}

Both `reduce()` and `accumulate()` are powerful functions from the `purrr` package that facilitate iterative calculations over a sequence, accumulating or reducing values based on a specified function.

Here's an explanation of each:

1. `reduce()`

   - `reduce()` is used to successively apply a function to pairs of elements in a sequence, reducing it to a single value.
   - The function provided to `reduce()` should take two arguments and return a single value.
   - It starts by applying the function to the first two elements, then uses the result along with the next element, and so on, until the sequence is exhausted.

   ==**Example**=={.note}

   ```R
   library(purrr)

   # Summing all elements in a vector using reduce()
   numbers = 1:5
   total_sum = reduce(numbers, `+`)

   total_sum
   # Output: 15 (1 + 2 + 3 + 4 + 5 = 15)
   ```

   Here, `reduce()` adds all the elements in the `numbers` vector by applying the addition function (`+`) iteratively.

2. `accumulate()`

   - `accumulate()` is similar to `reduce()` but returns a sequence of intermediate results instead of a single value.
   - It applies a function cumulatively to the sequence and returns a vector of values, representing the intermediate results at each step.

   ==**Example**=={.note}

   ```R
   # Calculating cumulative product of elements in a vector using accumulate()
   factors = c(2, 3, 4, 5)
   cumulative_product = accumulate(factors, `*`)

   cumulative_product
   # Output: 2 6 24 120 (2, 2*3, 2*3*4, 2*3*4*5)
   ```

   Here, `accumulate()` applies the multiplication function (`*`) to each element in `factors`, returning a vector of cumulative products at each step.

::: info
`reduce()` aggregates a sequence into a single value based on a function, while `accumulate()` returns a sequence of intermediate results. Both functions are helpful for iterative calculations and provide different ways to process sequences of values in R.
:::

## Parallel Computing {#parallel-computing}

Parallel computing is a method of computation in which many calculations or processes are carried out simultaneously. Large problems can often be divided into smaller ones, which can then be solved at the same time. In R, parallel computing can significantly speed up data processing tasks, especially when dealing with large datasets or computationally intensive operations.

In the context of R, parallel computing typically involves distributing tasks across multiple CPU cores or processors. This can be achieved using various packages that facilitate parallel execution of code.

### Related Packages {#related-packages}

- `parallel` package: displays the number of CPU cores to assign all or part to a task.
- `foreach` package: provides `%do%` and `%dopar%` operators to submit tasks for sequential or parallel computation
- ``iterators` package: splits `data.frame, tibble, matrix` into rows/columns for submitting parallel tasks.

### Step-by-step Guidance {#step-by-step-guidance}

1. Prepare Data

   Assume you have a large data frame named `my_data` that you want to process in parallel.

2. Setup Parallel Processing

   Load necessary packages and initialize parallel processing capabilities.

   ```R
   library(parallel)
   library(doParallel)
   library(foreach)
   library(iterators)

   # Set the number of cores/processors to be used
   num_cores = detectCores()

   # Initialize parallel backend
   cl = makeCluster(num_cores)
   registerDoParallel(cl)
   ```

3. Split Data Frame into Chunks

   Use the `iter()` function from the `iterators` package to create an iterator for chunks of your data frame.

   ```R
   # Define chunk size
   chunk_size = nrow(my_data) / num_cores

   # Create an iterator for the chunks
   my_iterator = iter(my_data, by = "row", chunksize = chunk_size)
   ```

4. Perform Parallel Computation

   Use `foreach()` from the `foreach` package along with `%dopar%` to apply a function to each chunk in parallel.

   ```R
   # Define a function to process each chunk
   process_chunk = function(chunk) {
     # Your processing logic for each chunk goes here
     # For example: summary(chunk)
     # Replace summary() with your specific data processing task
   }

   # Apply the function to each chunk in parallel
   results = foreach(chunk = my_iterator, .combine = rbind) %dopar% {
     process_chunk(chunk)
   }
   ```

5. Combine Results

   Collect and combine the results obtained from parallel processing.

   ```R
   # Combine or process the results obtained from parallel computation
   final_result = do.call(rbind, results)

   # Close the parallel cluster
   stopCluster(cl)
   ```

Replace the `process_chunk()` function with your specific data processing task. This approach parallelizes the processing of chunks of the data frame across multiple cores, allowing for faster computations, especially with large datasets.

::: note

- Ensure that the necessary packages (`parallel`, `doParallel`, `foreach`, `iterators`) are installed and loaded in your R environment.
- Adjust the `chunk_size` based on your data size and available system resources for optimal performance.
- When the task is completed, the allocated CPU core is reclaimed.
- Ensure that your specific data processing task is compatible with parallelization and that the benefits of parallel computing outweigh the overhead of parallelization.
- Also, consider potential dependencies or shared resources among iterations when parallelizing computations.
  :::

## Function `foreach()` {#function-foreach}

`foreach()` provides a simple and flexible way to perform iterations in R, especially when combined with parallel computing. It allows you to iterate over elements of a collection and apply a function to each element, either sequentially or in parallel.

### Description {#description-foreach}

`⁠%do%⁠` and `⁠%dopar%⁠` are binary operators that operate on a `foreach` object and an `R` expression. The expression, `ex`, is evaluated multiple times in an environment that is created by the `foreach` object, and that environment is modified for each evaluation as specified by the `foreach` object. `⁠%do%⁠` evaluates the expression sequentially, while `⁠%dopar%⁠` evaluates it in parallel. The results of evaluating `ex` are returned as a list by default, but this can be modified by means of the `.combine` argument.

### Usage {#usage-foreach}

```R :::collapsed-lines=5
foreach(
  ...,
  .combine,
  .init,
  .final = NULL,
  .inorder = TRUE,
  .multicombine = FALSE,
  .maxcombine = if (.multicombine) 100 else 2,
  .errorhandling = c("stop", "remove", "pass"),
  .packages = NULL,
  .export = NULL,
  .noexport = NULL,
  .verbose = FALSE
)
e1 %:% e2
when(cond)
obj %do% ex
obj %dopar% ex
times(n)
```

### Nested `foreach` Loops {#nested-foreach-loops}

::: info
Expanded knowledge, not featured on slide, for understanding only.
:::

Nested `foreach` loops in R allow for the iteration over multiple levels of nested structures or combinations of iterators. This approach is particularly useful when dealing with hierarchical data or when you need to perform computations on multiple levels of nested objects simultaneously.

Here's an overview of nested `foreach` loops:

1. Nested Iteration

   `foreach` supports nesting, allowing you to iterate over multiple levels of nested structures, such as lists within lists or matrices within lists.

   ```R
   library(foreach)

   # Example: Nested foreach loop iterating over a list of lists
   outer_list = list(list(a = 1, b = 2), list(c = 3, d = 4))

   foreach(inner_list = outer_list) %:% {
     foreach(element = inner_list) %do% {
       # Process each element within the nested structure
       print(element)
     }
   }
   ```

   This code iterates over each element of `outer_list`, which contains inner lists. Within each inner list, it iterates over the elements.

2. Combining Iterators

   You can combine different iterators using `%:%` to create nested iterations.

   ```R
   # Example: Nested foreach loop with combined iterators
   values = 1:3
   letters = letters[1:4]

   foreach(i = values) %:% foreach(letter = letters) %do% {
     # Perform operations using both iterators
     print(paste("Value:", i, "| Letter:", letter))
   }
   ```

   This code creates nested iterations, iterating over `values` and `letters` simultaneously.

3. Applying Nested Functions

   Nested `foreach` loops are valuable when applying functions or performing operations that require iterating over multiple levels of nested data structures or combinations.

   ```R
   # Example: Applying a function with nested foreach loops
   matrix_list = list(matrix(1:4, nrow = 2), matrix(5:8, nrow = 2))

   foreach(mat = matrix_list) %:% foreach(element = as.vector(mat)) %do% {
     # Perform computations on each element of each matrix
     print(element * 2)
   }
   ```

   Here, it iterates over a list of matrices and then iterates over each element within the matrices to perform computations.

Nested `foreach` loops in R allow for flexible and efficient iterations over hierarchical or nested structures, enabling complex computations, data manipulations, or simulations involving multiple levels of nested objects or iterators.
